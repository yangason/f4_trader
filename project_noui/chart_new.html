<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šçª—å£è¡Œæƒ…ç³»ç»Ÿ Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #1e222d;
            color: #ffffff;
            overflow: hidden;
        }

        .header {
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #0056b3;
        }

        .btn.success {
            background: #28a745;
        }

        .btn.success:hover {
            background: #1e7e34;
        }

        .layout-selector {
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #2d3748;
            color: white;
            cursor: pointer;
        }

        .main-container {
            height: calc(100vh - 60px);
            position: relative;
        }

        .window-grid {
            width: 100%;
            height: 100%;
            display: grid;
            gap: 2px;
            background: #2d3748;
            padding: 2px;
        }

        .window-grid.layout-1x2 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
        }

        .window-grid.layout-2x2 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .window-grid.layout-2x3 {
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .chart-window {
            background: #1e222d;
            border: 1px solid #2d3748;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .window-header {
            height: 40px;
            background: #2d3748;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            border-bottom: 1px solid #4a5568;
        }

        .window-title {
            font-size: 14px;
            font-weight: bold;
        }

        .window-controls {
            display: flex;
            gap: 5px;
        }

        .timeframe-selector {
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            background: #4a5568;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .close-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 3px;
            background: #e53e3e;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }

        .close-btn:hover {
            background: #c53030;
        }

        .chart-container {
            flex: 1;
            position: relative;
        }

        .chart {
            width: 100%;
            height: 100%;
        }

        .status-bar {
            height: 20px;
            background: #2d3748;
            display: flex;
            align-items: center;
            padding: 0 10px;
            font-size: 12px;
            color: #a0aec0;
        }

        .sync-indicator {
            margin-left: auto;
            padding: 2px 6px;
            background: #38a169;
            border-radius: 3px;
            font-size: 10px;
        }

        .sync-indicator.inactive {
            background: #718096;
        }

        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #718096;
            font-size: 16px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #4299e1;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #4299e1;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ å¤šçª—å£è¡Œæƒ…ç³»ç»Ÿ</h1>
        <div class="controls">
            <select class="layout-selector" id="layoutSelector">
                <option value="1x2">1x2 å¸ƒå±€</option>
                <option value="2x2">2x2 å¸ƒå±€</option>
                <option value="2x3">2x3 å¸ƒå±€</option>
            </select>
            <button class="btn" onclick="createWindow()">åˆ›å»ºçª—å£</button>
            <button class="btn" onclick="toggleSync()" id="syncBtn">åŒæ­¥åå­—çº¿: å¼€å¯</button>
            <button class="btn success" onclick="loadSampleData()">åŠ è½½ç¤ºä¾‹æ•°æ®</button>
            <button class="btn" onclick="addIndicators()">æ·»åŠ æŠ€æœ¯æŒ‡æ ‡</button>
            <button class="btn" onclick="toggleTheme()">åˆ‡æ¢ä¸»é¢˜</button>
            <button class="btn" onclick="testSync()">æµ‹è¯•åŒæ­¥</button>
        </div>
    </div>

    <div class="main-container">
        <div class="window-grid layout-1x2" id="windowGrid">
            <!-- çª—å£å°†åœ¨è¿™é‡ŒåŠ¨æ€åˆ›å»º -->
        </div>
    </div>

    <!-- å¼•å…¥ TradingView Lightweight Charts V5 -->
    <script src="https://unpkg.com/lightweight-charts@5.0.8/dist/lightweight-charts.standalone.production.js"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let windows = new Map();
        let crosshairSyncEnabled = true;
        let isSyncing = false;
        let currentLayout = '1x2';
        let windowCounter = 0;
        let isDarkTheme = false;

        // æ—¶é—´æ¡†æ¶é€‰é¡¹
        const timeframes = [
            { value: '1m', label: '1åˆ†é’Ÿ' },
            { value: '5m', label: '5åˆ†é’Ÿ' },
            // { value: '15m', label: '15åˆ†é’Ÿ' },
            // { value: '30m', label: '30åˆ†é’Ÿ' },
            // { value: '1h', label: '1å°æ—¶' },
            // { value: '4h', label: '4å°æ—¶' },
            { value: '1d', label: 'æ—¥çº¿' }
        ];

        // äº¤æ˜“å¯¹é€‰é¡¹
        const symbols = [
            { value: 'ZH_STOCK', label: 'ZH_STOCK' },
            { value: 'BTCUSDT', label: 'BTC/USDT' },
            { value: 'ETHUSDT', label: 'ETH/USDT' },
            { value: 'BNBUSDT', label: 'BNB/USDT' },
            { value: 'ADAUSDT', label: 'ADA/USDT' }
        ];

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initLayout();
            createInitialWindows();
        });

        // åˆå§‹åŒ–å¸ƒå±€
        function initLayout() {
            const layoutSelector = document.getElementById('layoutSelector');
            layoutSelector.addEventListener('change', (e) => {
                currentLayout = e.target.value;
                updateLayout();
            });
        }

        // æ›´æ–°å¸ƒå±€
        function updateLayout() {
            const grid = document.getElementById('windowGrid');
            grid.className = `window-grid layout-${currentLayout}`;
            
            // æ ¹æ®å¸ƒå±€è°ƒæ•´çª—å£æ•°é‡
            const maxWindows = getMaxWindowsForLayout(currentLayout);
            const currentWindows = windows.size;
            
            if (currentWindows < maxWindows) {
                // æ·»åŠ ç¼ºå°‘çš„çª—å£
                for (let i = currentWindows; i < maxWindows; i++) {
                    createWindow();
                }
            } else if (currentWindows > maxWindows) {
                // ç§»é™¤å¤šä½™çš„çª—å£
                const windowIds = Array.from(windows.keys());
                for (let i = maxWindows; i < currentWindows; i++) {
                    destroyWindow(windowIds[i]);
                }
            }
        }

        // è·å–å¸ƒå±€çš„æœ€å¤§çª—å£æ•°
        function getMaxWindowsForLayout(layout) {
            switch(layout) {
                case '1x2': return 2;
                case '2x2': return 4;
                case '2x3': return 6;
                default: return 2;
            }
        }

        // åˆ›å»ºåˆå§‹çª—å£
        function createInitialWindows() {
            const maxWindows = getMaxWindowsForLayout(currentLayout);
            for (let i = 0; i < maxWindows; i++) {
                createWindow();
            }
        }

        // åˆ›å»ºæ–°çª—å£
        function createWindow() {
            const windowId = `window_${++windowCounter}`;
            const symbol = symbols[windowCounter % symbols.length];
            const timeframe = timeframes[windowCounter % timeframes.length];
            
            // åˆ›å»ºçª—å£HTML
            const windowElement = createWindowElement(windowId, symbol, timeframe);
            
            // æ·»åŠ åˆ°ç½‘æ ¼
            const grid = document.getElementById('windowGrid');
            grid.appendChild(windowElement);
            
            // åˆ›å»ºå›¾è¡¨
            createChart(windowId, symbol.value, timeframe.value);
            
            return windowId;
        }

        // åˆ›å»ºçª—å£HTMLå…ƒç´ 
        function createWindowElement(windowId, symbol, timeframe) {
            const windowDiv = document.createElement('div');
            windowDiv.className = 'chart-window';
            windowDiv.id = windowId;
            
            windowDiv.innerHTML = `
                <div class="window-header">
                    <div class="window-title">${symbol.label} ${timeframe.label}</div>
                    <div class="window-controls">
                        <select class="timeframe-selector" onchange="changeTimeframe('${windowId}', this.value)">
                            ${timeframes.map(tf => 
                                `<option value="${tf.value}" ${tf.value === timeframe.value ? 'selected' : ''}>${tf.label}</option>`
                            ).join('')}
                        </select>
                        <button class="close-btn" onclick="destroyWindow('${windowId}')">Ã—</button>
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart" id="chart_${windowId}"></div>
                </div>
                <div class="status-bar">
                    <span>å°±ç»ª</span>
                    <span class="sync-indicator ${crosshairSyncEnabled ? '' : 'inactive'}">
                        ${crosshairSyncEnabled ? 'åŒæ­¥å¼€å¯' : 'åŒæ­¥å…³é—­'}
                    </span>
                </div>
            `;
            
            return windowDiv;
        }

        // åˆ›å»ºå›¾è¡¨
        function createChart(windowId, symbol, timeframe) {
            const chartContainer = document.getElementById(`chart_${windowId}`);
            
            // åˆ›å»ºå›¾è¡¨å®ä¾‹
            const chart = LightweightCharts.createChart(chartContainer, {
                width: chartContainer.clientWidth,
                height: chartContainer.clientHeight,
                layout: {
                    background: { color: '#1e222d' },
                    textColor: '#ffffff',
                },
                grid: {
                    vertLines: { color: '#2B2B43' },
                    horzLines: { color: '#2B2B43' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                    scaleMargins: {
                        top: 0.1,
                        bottom: 0.3,
                    },
                    visible: true,
                    autoScale: true,
                },
                timeScale: {
                    borderColor: '#2B2B43',
                    timeVisible: true,
                    secondsVisible: false,
                },
                handleScroll: {
                    mouseWheel: true,
                    pressedMouseMove: true,
                    horzTouchDrag: true,
                    vertTouchDrag: true,
                },
                handleScale: {
                    axisPressedMouseMove: true,
                    mouseWheel: true,
                    pinch: true,
                },
            });

            // V5æ–°APIï¼šä½¿ç”¨addSeriesæ–¹æ³•åˆ›å»ºKçº¿ç³»åˆ—
            const candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });



            // è®¢é˜…åå­—çº¿ç§»åŠ¨äº‹ä»¶
            chart.subscribeCrosshairMove((param) => {
                if (crosshairSyncEnabled && !isSyncing) {
                    if (param.time) {
                        // è·å–ä»·æ ¼ä¿¡æ¯
                        const price = param.seriesPrices?.get(candlestickSeries)?.close || param.point?.y;
                        if (price != null) {
                            syncCrosshairPosition(param.time, windowId, price);
                        }
                    } else {
                        // å½“åå­—çº¿ç¦»å¼€æ—¶ï¼Œæ¸…é™¤æ‰€æœ‰å…¶ä»–çª—å£çš„åå­—çº¿
                        windows.forEach((otherWindow, otherWindowId) => {
                            if (otherWindowId !== windowId) {
                                try {
                                    otherWindow.chart.clearCrosshairPosition();
                                } catch (e) {
                                    console.log('æ¸…é™¤åå­—çº¿å¤±è´¥:', e);
                                }
                            }
                        });
                    }
                }
            });

            // å­˜å‚¨çª—å£ä¿¡æ¯
            windows.set(windowId, {
                chart,
                candlestickSeries,
                symbol,
                timeframe,
                element: document.getElementById(windowId)
            });

            // åŠ è½½ç¤ºä¾‹æ•°æ®
            loadDataForWindow(windowId);
        }

        // ä¸ºçª—å£åŠ è½½æ•°æ®
        function loadDataForWindow(windowId) {
            const window = windows.get(windowId);
            if (!window) return;

            // æ ¹æ®æ—¶é—´æ¡†æ¶åŠ è½½å¯¹åº”çš„CSVæ•°æ®
            loadCSVData(windowId, window.timeframe);
        }

        async function loadMysqlData(windowId, timeframe) {

        }

        // åŠ è½½CSVæ•°æ®
        async function loadCSVData(windowId, timeframe) {
            const window = windows.get(windowId);
            if (!window) return;

            try {
                let csvPath;
                if (timeframe === '1m') {
                    csvPath = './data/demo_data_1min.csv';
                } else if (timeframe === '5m') {
                    csvPath = './data/demo_data_5min.csv';
                } else {
                    // å¯¹äºå…¶ä»–æ—¶é—´æ¡†æ¶ï¼Œä½¿ç”¨1åˆ†é’Ÿæ•°æ®
                    csvPath = './data/demo_data_1min.csv';
                }

                const response = await fetch(csvPath);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                const lines = csvText.split('\n');
                const data = [];
                
                // è·³è¿‡æ ‡é¢˜è¡Œ
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line) {
                        const columns = line.split(',');
                        if (columns.length >= 5) {
                            const timestamp = new Date(columns[0]);
                            data.push({
                                time: Math.floor(timestamp.getTime() / 1000),
                                open: parseFloat(columns[1]),
                                high: parseFloat(columns[2]),
                                low: parseFloat(columns[3]),
                                close: parseFloat(columns[4]),
                            });
                        }
                    }
                }
                
                window.candlestickSeries.setData(data);
                window.chart.timeScale().fitContent();
                
                // å¼ºåˆ¶æ›´æ–°ä»·æ ¼åˆ»åº¦
                setTimeout(() => {
                    window.chart.priceScale('right').applyOptions({
                        autoScale: true,
                        visible: true,
                    });
                }, 100);
                
                updateWindowStatus(windowId, 'æ•°æ®å·²åŠ è½½');
                
            } catch (error) {
                console.error('åŠ è½½CSVæ•°æ®å¤±è´¥:', error);
                updateWindowStatus(windowId, 'æ•°æ®åŠ è½½å¤±è´¥');
            }
        }

        // åˆ‡æ¢æ—¶é—´æ¡†æ¶
        function changeTimeframe(windowId, newTimeframe) {
            const window = windows.get(windowId);
            if (!window) return;

            window.timeframe = newTimeframe;
            
            // æ›´æ–°æ ‡é¢˜
            const titleElement = window.element.querySelector('.window-title');
            const symbolLabel = symbols.find(s => s.value === window.symbol)?.label || window.symbol;
            const timeframeLabel = timeframes.find(tf => tf.value === newTimeframe)?.label || newTimeframe;
            titleElement.textContent = `${symbolLabel} ${timeframeLabel}`;
            
            // é‡æ–°åŠ è½½æ•°æ®
            loadDataForWindow(windowId);
        }

        // åŒæ­¥åå­—çº¿ä½ç½®
        function syncCrosshairPosition(time, sourceWindowId, price) {
            if (!crosshairSyncEnabled) return;
            
            console.log(`åŒæ­¥åå­—çº¿: æ—¶é—´=${time}, ä»·æ ¼=${price}, æºçª—å£=${sourceWindowId}`);
            
            isSyncing = true;
            
            windows.forEach((window, windowId) => {
                if (windowId !== sourceWindowId) {
                    // å¯¹é½æ—¶é—´åˆ°å½“å‰æ—¶é—´æ¡†æ¶
                    const alignedTime = alignTimeToTimeframe(time, window.timeframe);
                    console.log(`è®¾ç½®çª—å£ ${windowId} åå­—çº¿ä½ç½®: ä»·æ ¼=${price}, æ—¶é—´=${alignedTime}`);
                    
                    try {
                        // ä½¿ç”¨æ­£ç¡®çš„APIè°ƒç”¨æ–¹å¼ï¼šä»·æ ¼åœ¨å‰ï¼Œæ—¶é—´åœ¨åï¼Œç³»åˆ—æœ€å
                        window.chart.setCrosshairPosition(
                            price,
                            alignedTime,
                            window.candlestickSeries
                        );
                    } catch (error) {
                        console.error('è®¾ç½®åå­—çº¿å¤±è´¥:', error);
                    }
                }
            });
            
            // ç«‹å³é‡ç½®åŒæ­¥çŠ¶æ€
            isSyncing = false;
        }

        // æ—¶é—´å¯¹é½
        function alignTimeToTimeframe(time, timeframe) {
            const date = new Date(time * 1000);
            
            switch(timeframe) {
                case '1m':
                    date.setSeconds(0, 0);
                    break;
                case '5m':
                    const minutes5 = date.getMinutes();
                    const alignedMinutes5 = Math.floor(minutes5 / 5) * 5;
                    date.setMinutes(alignedMinutes5, 0, 0);
                    break;
                case '15m':
                    const minutes15 = date.getMinutes();
                    const alignedMinutes15 = Math.floor(minutes15 / 15) * 15;
                    date.setMinutes(alignedMinutes15, 0, 0);
                    break;
                case '30m':
                    const minutes30 = date.getMinutes();
                    const alignedMinutes30 = Math.floor(minutes30 / 30) * 30;
                    date.setMinutes(alignedMinutes30, 0, 0);
                    break;
                case '1h':
                    date.setMinutes(0, 0, 0);
                    break;
                case '4h':
                    const hours4 = date.getHours();
                    const alignedHours4 = Math.floor(hours4 / 4) * 4;
                    date.setHours(alignedHours4, 0, 0, 0);
                    break;
                case '1d':
                    date.setHours(0, 0, 0, 0);
                    break;
            }
            
            const alignedTime = Math.floor(date.getTime() / 1000);
            console.log(`æ—¶é—´å¯¹é½: ${time} -> ${alignedTime} (${timeframe})`);
            return alignedTime;
        }

        // åˆ‡æ¢åŒæ­¥çŠ¶æ€
        function toggleSync() {
            crosshairSyncEnabled = !crosshairSyncEnabled;
            const syncBtn = document.getElementById('syncBtn');
            syncBtn.textContent = `åŒæ­¥åå­—çº¿: ${crosshairSyncEnabled ? 'å¼€å¯' : 'å…³é—­'}`;
            
            // æ›´æ–°æ‰€æœ‰çª—å£çš„åŒæ­¥æŒ‡ç¤ºå™¨
            windows.forEach((window, windowId) => {
                const indicator = window.element.querySelector('.sync-indicator');
                indicator.textContent = crosshairSyncEnabled ? 'åŒæ­¥å¼€å¯' : 'åŒæ­¥å…³é—­';
                indicator.classList.toggle('inactive', !crosshairSyncEnabled);
            });
        }

        // åŠ è½½ç¤ºä¾‹æ•°æ®
        function loadSampleData() {
            windows.forEach((window, windowId) => {
                loadDataForWindow(windowId);
            });
        }

        // é”€æ¯çª—å£
        function destroyWindow(windowId) {
            const window = windows.get(windowId);
            if (!window) return;

            // é”€æ¯å›¾è¡¨
            window.chart.remove();
            
            // ç§»é™¤DOMå…ƒç´ 
            window.element.remove();
            
            // ä»Mapä¸­åˆ é™¤
            windows.delete(windowId);
        }

        // æ›´æ–°çª—å£çŠ¶æ€
        function updateWindowStatus(windowId, status) {
            const window = windows.get(windowId);
            if (!window) return;

            const statusElement = window.element.querySelector('.status-bar span:first-child');
            statusElement.textContent = status;
        }

        // æ·»åŠ æŠ€æœ¯æŒ‡æ ‡
        function addIndicators() {
            windows.forEach((window, windowId) => {
                addMovingAverage(windowId);
                addRSIPane(windowId);
            });
        }

        // ä¸ºæŒ‡å®šçª—å£æ·»åŠ ç§»åŠ¨å¹³å‡çº¿
        function addMovingAverage(windowId) {
            const window = windows.get(windowId);
            if (!window || window.maSeries) return;

            try {
                // V5æ–°APIï¼šä½¿ç”¨addSeriesæ–¹æ³•
                window.maSeries = window.chart.addSeries(LightweightCharts.LineSeries, {
                    color: '#ff9800',
                    lineWidth: 2,
                    title: 'MA20',
                });
                
                // è®¡ç®—ç§»åŠ¨å¹³å‡çº¿
                const candlestickData = window.candlestickSeries.data();
                if (candlestickData.length > 0) {
                    const maData = [];
                    const period = 20;
                    
                    for (let i = period - 1; i < candlestickData.length; i++) {
                        let sum = 0;
                        for (let j = 0; j < period; j++) {
                            sum += candlestickData[i - j].close;
                        }
                        const ma = sum / period;
                        maData.push({
                            time: candlestickData[i].time,
                            value: ma,
                        });
                    }
                    
                    window.maSeries.setData(maData);
                    updateWindowStatus(windowId, 'MA20å·²æ·»åŠ ');
                }
            } catch (error) {
                console.error('æ·»åŠ ç§»åŠ¨å¹³å‡çº¿å¤±è´¥:', error);
            }
        }

        // ä¸ºæŒ‡å®šçª—å£æ·»åŠ RSIæŒ‡æ ‡çª—æ ¼
        function addRSIPane(windowId) {
            const window = windows.get(windowId);
            if (!window || window.rsiPane) return;

            try {
                // åˆ›å»ºRSIçª—æ ¼
                window.rsiPane = window.chart.addPane(150, {
                    background: { color: isDarkTheme ? '#1e222d' : '#f8f9fa' },
                    grid: {
                        vertLines: { color: isDarkTheme ? '#2B2B43' : '#e9ecef' },
                        horzLines: { color: isDarkTheme ? '#2B2B43' : '#e9ecef' },
                    },
                });

                // åœ¨RSIçª—æ ¼ä¸­æ·»åŠ RSIç³»åˆ—
                window.rsiSeries = window.rsiPane.addSeries(LightweightCharts.LineSeries, {
                    color: '#ff9800',
                    lineWidth: 2,
                    title: 'RSI(14)',
                });

                // æ·»åŠ RSIçš„è¶…ä¹°è¶…å–çº¿
                const overboughtLine = window.rsiPane.addSeries(LightweightCharts.LineSeries, {
                    color: '#ff4444',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'è¶…ä¹°çº¿(70)',
                });

                const oversoldLine = window.rsiPane.addSeries(LightweightCharts.LineSeries, {
                    color: '#44ff44',
                    lineWidth: 1,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    title: 'è¶…å–çº¿(30)',
                });

                // è®¡ç®—å¹¶è®¾ç½®RSIæ•°æ®
                const candlestickData = window.candlestickSeries.data();
                if (candlestickData.length > 0) {
                    const rsiData = calculateRSI(candlestickData, 14);
                    window.rsiSeries.setData(rsiData);

                    // è®¾ç½®è¶…ä¹°è¶…å–çº¿
                    const timeRange = rsiData.length > 0 ? {
                        from: rsiData[0].time,
                        to: rsiData[rsiData.length - 1].time
                    } : null;

                    if (timeRange) {
                        overboughtLine.setData([
                            { time: timeRange.from, value: 70 },
                            { time: timeRange.to, value: 70 }
                        ]);
                        oversoldLine.setData([
                            { time: timeRange.from, value: 30 },
                            { time: timeRange.to, value: 30 }
                        ]);
                    }

                    updateWindowStatus(windowId, 'RSIæŒ‡æ ‡å·²æ·»åŠ ');
                }
            } catch (error) {
                console.error('æ·»åŠ RSIæŒ‡æ ‡å¤±è´¥:', error);
            }
        }

        // è®¡ç®—RSIå‡½æ•°
        function calculateRSI(data, period = 14) {
            const rsiData = [];
            
            if (data.length < period + 1) {
                return rsiData;
            }

            let gains = [];
            let losses = [];

            // è®¡ç®—ä»·æ ¼å˜åŒ–
            for (let i = 1; i < data.length; i++) {
                const change = data[i].close - data[i - 1].close;
                gains.push(change > 0 ? change : 0);
                losses.push(change < 0 ? -change : 0);
            }

            // è®¡ç®—åˆå§‹å¹³å‡å€¼
            let avgGain = gains.slice(0, period).reduce((sum, gain) => sum + gain, 0) / period;
            let avgLoss = losses.slice(0, period).reduce((sum, loss) => sum + loss, 0) / period;

            // æ·»åŠ ç¬¬ä¸€ä¸ªRSIå€¼
            const firstRSI = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
            rsiData.push({
                time: data[period].time,
                value: firstRSI
            });

            // è®¡ç®—åç»­RSIå€¼
            for (let i = period; i < data.length - 1; i++) {
                avgGain = (avgGain * (period - 1) + gains[i]) / period;
                avgLoss = (avgLoss * (period - 1) + losses[i]) / period;

                const rsi = avgLoss === 0 ? 100 : 100 - (100 / (1 + avgGain / avgLoss));
                rsiData.push({
                    time: data[i + 1].time,
                    value: rsi
                });
            }

            return rsiData;
        }

        // åˆ‡æ¢ä¸»é¢˜
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            
            const theme = isDarkTheme ? {
                background: { color: '#1e222d' },
                textColor: '#ffffff',
                grid: {
                    vertLines: { color: '#2B2B43' },
                    horzLines: { color: '#2B2B43' },
                },
                rightPriceScale: {
                    borderColor: '#2B2B43',
                },
                timeScale: {
                    borderColor: '#2B2B43',
                },
            } : {
                background: { color: '#ffffff' },
                textColor: '#333',
                grid: {
                    vertLines: { color: '#f0f0f0' },
                    horzLines: { color: '#f0f0f0' },
                },
                rightPriceScale: {
                    borderColor: '#ddd',
                },
                timeScale: {
                    borderColor: '#ddd',
                },
            };
            
            // æ›´æ–°æ‰€æœ‰çª—å£çš„ä¸»é¢˜
            windows.forEach((window, windowId) => {
                window.chart.applyOptions(theme);
                
                // å¦‚æœRSIçª—æ ¼å­˜åœ¨ï¼Œä¹Ÿæ›´æ–°å…¶ä¸»é¢˜
                if (window.rsiPane) {
                    const rsiTheme = isDarkTheme ? {
                        background: { color: '#1e222d' },
                        grid: {
                            vertLines: { color: '#2B2B43' },
                            horzLines: { color: '#2B2B43' },
                        },
                    } : {
                        background: { color: '#f8f9fa' },
                        grid: {
                            vertLines: { color: '#e9ecef' },
                            horzLines: { color: '#e9ecef' },
                        },
                    };
                    window.rsiPane.applyOptions(rsiTheme);
                }
            });
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const buttons = document.querySelectorAll('.controls button');
            buttons[4].classList.toggle('active', isDarkTheme);
        }

        // æµ‹è¯•åŒæ­¥åŠŸèƒ½
        function testSync() {
            const now = Math.floor(Date.now() / 1000);
            const testPrice = 50000; // æµ‹è¯•ä»·æ ¼
            console.log('æµ‹è¯•åŒæ­¥åŠŸèƒ½ï¼Œæ—¶é—´:', now, 'ä»·æ ¼:', testPrice);
            syncCrosshairPosition(now, 'window_1', testPrice);
        }

        // çª—å£å¤§å°è°ƒæ•´å¤„ç† - V5æ–°API
        window.addEventListener('resize', () => {
            windows.forEach((window, windowId) => {
                const chartContainer = document.getElementById(`chart_${windowId}`);
                window.chart.applyOptions({
                    width: chartContainer.clientWidth,
                    height: chartContainer.clientHeight,
                });
            });
        });
    </script>
</body>
</html> 